package security.br.ufal.ic.temp;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

public class MainTest {
	public static Iterable<MatchResult> allMatches(
		      final Pattern p, final CharSequence input) {
		  return new Iterable<MatchResult>() {
		    public Iterator<MatchResult> iterator() {
		      return new Iterator<MatchResult>() {
		        // Use a matcher internally.
		        final Matcher matcher = p.matcher(input);
		        // Keep a match around that supports any interleaving of hasNext/next calls.
		        MatchResult pending;

		        public boolean hasNext() {
		          // Lazily fill pending, and avoid calling find() multiple times if the
		          // clients call hasNext() repeatedly before sampling via next().
		          if (pending == null && matcher.find()) {
		            pending = matcher.toMatchResult();
		          }
		          return pending != null;
		        }

		        public MatchResult next() {
		          // Fill pending if necessary (as when clients call next() without
		          // checking hasNext()), throw if not possible.
		          if (!hasNext()) { throw new NoSuchElementException(); }
		          // Consume pending so next call to hasNext() does a find().
		          MatchResult next = pending;
		          pending = null;
		          return next;
		        }

		        /** Required to satisfy the interface, but unsupported. */
		        public void remove() { throw new UnsupportedOperationException(); }
		      };
		    }
		  };
		}

	
	public static void main(String[] args) throws IOException {
		Document doc = Jsoup.connect("http://xenbits.xen.org/xsa/xsa99.patch").get();
//
		String text = doc.getElementsByTag("body").text();
//		List<String> lista1 = new ArrayList<String>();
//		Pattern pattern1 = Pattern.compile("(--\\s*git.+?(tools.+?\\s).+index\\s+(.+?\\s))");
//		Pattern pattern11 = Pattern.compile(
//				"@@\\s*(private|public|protected|static|int|virtual|void|boolean|float|char|String|long|\\s*)\\s*(.*?\\()");
//		Matcher matcher11 = pattern11.matcher(text);
//		Matcher matcher1 = pattern1.matcher(text);
//		while(matcher1.find()){
//			System.out.println(matcher1.start()+matcher1.group()+"\n");
//			
//		}
//	
	
		List<String> allMatches = new ArrayList<String>();
		 Matcher m = Pattern.compile("(--\\s*git.+?(tools.+?\\s).+index\\s+(.+?\\s))")
		     .matcher(text);
		 while (m.find()) {
		   allMatches.add(m.group(2));
		 }
		 for(String e:allMatches){
			 System.out.println(e);
			 System.out.println(allMatches.size());
		 }
		
	}

}
