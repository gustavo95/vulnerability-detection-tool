package security.br.ufal.ic.temp;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.eclipse.cdt.core.dom.ast.ASTVisitor;
import org.eclipse.cdt.core.dom.ast.IASTDeclaration;
import org.eclipse.cdt.core.dom.ast.IASTDeclarator;
import org.eclipse.cdt.core.dom.ast.IASTDefaultStatement;
import org.eclipse.cdt.core.dom.ast.IASTFieldDeclarator;
import org.eclipse.cdt.core.dom.ast.IASTNode;
import org.eclipse.cdt.core.dom.ast.IASTStatement;
import org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;
import org.eclipse.cdt.core.dom.ast.IVariable;
import org.eclipse.cdt.core.dom.lrparser.gnu.GPPLanguage;
import org.eclipse.cdt.core.parser.DefaultLogService;
import org.eclipse.cdt.core.parser.FileContent;
import org.eclipse.cdt.core.parser.IParserLogService;
import org.eclipse.cdt.core.parser.IScannerInfo;
import org.eclipse.cdt.core.parser.IncludeFileContentProvider;
import org.eclipse.cdt.core.parser.ScannerInfo;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTAmbiguousCastVsFunctionCallExpression;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTDeclarator;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTExpressionStatement;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTFieldDeclarator;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTFunctionDeclarator;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTFunctionDefinition;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTIfStatement;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTSimpleDeclSpecifier;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPASTSimpleDeclaration;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPBuiltinVariable;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassInstance;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPClassType;
import org.eclipse.cdt.internal.core.dom.parser.cpp.CPPVariable;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.dom.ASTNode;
import org.omg.PortableServer.IdAssignmentPolicyValue;

public class CreateASTCPPC {
	static int ifcount = 0;
	static int funcdefinitioncount = 0;
	static int funccallcount = 0;
	static int variablecount = 0;

	public static void main(String[] args) throws Exception, CoreException {
		// int[] array= {1,2,3,4,5};
		parse("/Users/marcus/Documents/Master Graduate/Change History/Repository/security-change-history/change-history-code/src/main/java/security/br/ufal/ic/temp/file.c");
	}

	public static void parse(String str) throws CoreException {

		long start = System.currentTimeMillis();

		FileContent fileContent = FileContent.createForExternalFileLocation(str, "UTF-8");

		// System.out.println(fileContent.getFileLocation());

		Map definedSymbols = new HashMap();
		String[] includePaths = new String[0];
		IScannerInfo info = new ScannerInfo(definedSymbols, includePaths);
		IParserLogService log = new DefaultLogService();

		IncludeFileContentProvider emptyIncludes = IncludeFileContentProvider.getEmptyFilesProvider();

		int opts = 8;
		IASTTranslationUnit tu = GPPLanguage.getDefault().getASTTranslationUnit(fileContent, info, emptyIncludes, null,
				opts, log);

		ASTVisitor visitor = new ASTVisitor(true) {

			public int visit(IASTDeclarator decl) {
				// for(int i: lineList){

				if (decl instanceof CPPASTFunctionDeclarator) {
					funcdefinitioncount++;
				} else if (decl instanceof CPPASTDeclarator) {
					variablecount++;
				}
				// }}
				return PROCESS_CONTINUE;

			}

			public int visit(IASTStatement statment) {
				if (statment instanceof CPPASTIfStatement) {
					ifcount++;
					IASTNode temp = statment;

					// System.out.println(temp.getParent().getParent());

					while (temp.getParent().getClass() != CPPASTFunctionDefinition.class) {
						// System.out.println(temp.getParent().getClass());
						temp = temp.getParent();
					}
					System.out.println(temp.getParent().getRawSignature());

				} else if (statment instanceof CPPASTExpressionStatement) {
					if (!statment.getRawSignature().contains("printf") && !statment.getRawSignature().contains("scanf"))
						funccallcount++;
					// System.out.println("----------------------function: "
					// + statment.getRawSignature());
				}

				// System.out.println(statment.getClass().getSimpleName()
				// + "linha "
				// + statment.getFileLocation().getStartingLineNumber());

				return PROCESS_CONTINUE;

			}

		};

		ASTVisitor extractFunctionSignatures = new ASTVisitor(true) {
			public int visit(IASTDeclarator node) {
				Pattern pattern = Pattern.compile("(.*\\(.*\\))");
				Matcher matcher = pattern.matcher(node.getRawSignature());

				if (matcher.find()) {
					System.out.println(node.getRawSignature());
					if (node.getRawSignature().contains("retorno(inft ")) {
						System.out.println(1);
					}
					// IASTNode parameters[] = node.getChildren();
					// for(int i = 1; i < parameters.length; i++){
					// System.out.println(parameters[i].getRawSignature());
					// }
				}

				return PROCESS_CONTINUE;
			}
		};

		tu.accept(extractFunctionSignatures);

		tu.accept(visitor);
		long end = System.currentTimeMillis();

		System.out.println(ifcount);
		System.out.println(funccallcount);
		System.out.println(variablecount);
		System.out.println(funcdefinitioncount);
		System.out.println("Took : " + ((end - start) / 1000.0));

	}
}