package security.br.ufal.ic.classification;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Patterns for to classify!
 * <p>
 * TODO: NA verify
 * <p>
 */
public class ODCClassifiers {

	/**
	 * *
	 * <p>
	 * // TODO:MP o regex nao faz sentido... o que deve apanhar?
	 * <p>
	 * 
	 * @param line
	 * @return
	 */
	/**
	 * *
	 * <p>
	 * // TODO:NA
	 * <p>
	 * 
	 * @param line
	 * @return
	 */

	public boolean searchTokenVariable(String line) {
		// String patterns = "([\\w ]+\\=[\\w ]+.*?$)";
//		System.out.println(line);
    	if(line.contains("for")||line.contains("if")){
    		return false;}
		 String patterns = "(?!\\for\\()([\\w ]+\\=[\\w ]+.*?)|([\\w]+\\:?\\:?[\\w ]+\\[\\w*\\]?[\\w ]+\\=\\s*[{,;].*?)";

		//// (?<=\\s)(\\=)\\s.+|(?<=\\s)(\\=).+|(\\=)\\s.+|(\\=).+
		//// (?<!for)(?<!if)(=.*?\;\n)
		 Pattern pattern = Pattern.compile(patterns);
		 Matcher matcher = pattern.matcher(line);
		 if (matcher.find()) {
		 return true;
		 }
		 return false;
		 
		//Mais correta até 09 de março
		//([\\w ]+\\=[\\w ]+.*?)
//		return line.matches("([\\w ]+\\=[\\w ]+.*?)|([\\w]+\\:?\\:?[\\w ]+\\[\\w*\\]?[\\w ]+\\=\\s*[{,;].*?)");
	}

	public boolean searchTokenConditionalStates(String line) {
		// return line.matches("(if\\s*\\()|(else\\s+if\\s*\\()|(else\\s+\\{)");
		String patterns = "(if\\s*\\()|(else\\s+if\\s*\\()|(else\\s*\\{)";
		// (if)\s*\((.*?)\)|(else\s*if)\s*\((.*?)\)|(else)\n
		Pattern pattern = Pattern.compile(patterns);
		Matcher matcher = pattern.matcher(line);
		if (matcher.find()) {
			return true;
		}
		return false;
	}

	public boolean searchTokenFunctionCall(String line) {
		// TODO:MP Porque '[a-zA-Z]+' e nao \\w+
		// TODO: NA já Mudei a observação acima
		// String patterns = "\\w+\\([^\\)]*\\)(\\.[^\\)]*\\))?;";
		// (return|^int).*?\;|(\=[ \w].*?\;)|\w+\(?\);
		// [a-zA-Z]+\([^\)]*\)(\.[^\)]*\))?;
		// Pattern pattern = Pattern.compile(patterns);
		// Matcher matcher = pattern.matcher(line);
		// if (matcher.find()) {
		// return true;
		// }
		// return false;
		if(line.contains("for")||line.contains("if")){
    		return false;}
		return line.matches("(return.*?\\;?)|([\\w ]+\\=[ \\w].*?\\;?)|\\w+\\(.*?\\).*?;?");
	}

	public boolean searchTokenFunction(String line) {

		String patterns = "((!return |int|double|bool|char|short" + "|integer|long|float|long double|long long|"
				+ "void|static void|static int|static integer|static double|"
				+ "static long|static long long|static bool|static char|"
				+ "static short|static float|static long double|unsigned char|signed char|"
				+ "unsigned int|signed int|short int|unsigned short int|signed short int|"
				+ "long int|signed long int|unsigned long int|wchar_t|static unsigned char|"
				+ "static signed char|static unsigned int|static signed int|static short int|"
				+ "static unsigned short int|static signed short int|"
				+ "static long int|static signed long int|static unsigned long int|" + "static wchar_t)[\\w ]*\\()|([\\w ]+:\\s*?:\\s*?[\\w ]+\\(?)";

		// String patterns = "(\\w+[^return]\\s\\w+\\()";
		// (?<!@@ \w)(\w[ a-zA-Z_0-9\*\<\>\:]+) +(\\w+)\(
		// ([a-zA-Z_0-9\\*\\<\\>\\:]+)[^return] +(\\w+)\\(
		// (\* )(.*) comentário
		// ([a-zA-Z_0-9\*\<\>\:]+)[^return] +(\w+)\(
		Pattern pattern = Pattern.compile(patterns);
		Matcher matcher = pattern.matcher(line);
		if (matcher.find()) {
			return true;
		}
		return false;
	}

}
