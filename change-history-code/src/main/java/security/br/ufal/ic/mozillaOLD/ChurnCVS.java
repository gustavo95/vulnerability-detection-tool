package security.br.ufal.ic.mozillaOLD;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/* Vers�es para Compute Churn
//a.computeChurn("R2churn.csv","R2churnout.txt","1.0.3","1.0.6");
//		a.computeChurn("R3.csv","R3churn.csv","1.0.7","1.5.0.1");
//		a.computeChurn("R4.csv","R4churn.csv","1.5.0.2","1.5.0.4");
//		a.computeChurn("R5.csv","R5churn.csv","1.5.0.5","1.5.0.7");
//		a.computeChurn("R6.csv","R6churn.csv","1.5.0.8","2.0.0.1");
//		a.computeChurn("R7.csv","R7churn.csv","2.0.0.2","2.0.0.4");
//		a.computeChurn("R8.csv","R8churn.csv","2.0.0.5","2.0.0.7");
//		a.computeChurn("R9.csv","R9churn.csv","2.0.0.8","2.0.0.10");
//		a.computeChurn("R10.csv","R10churn.csv","2.0.0.11","2.0.0.13");
//		a.computeChurn("R11.csv","R11churn.csv","2.0.0.14","2.0.0.16");
		
//		a.computeChurn("R1.csv","R1churn.csv","1.0","1.0.2");
//		a.computeChurn("R2.csv","R2churn.csv","1.0","1.0.6");
//		a.computeChurn("R3.csv","R3churn.csv","1.0","1.5.0.1");
//		a.computeChurn("R4.csv","R4churn.csv","1.0","1.5.0.4");
//		a.computeChurn("R5.csv","R5churn.csv","1.0","1.5.0.7");
//		a.computeChurn("R6.csv","R6churn.csv","1.0","2.0.0.1");
//		a.computeChurn("R7.csv","R7churn.csv","1.0","2.0.0.4");
//		a.computeChurn("R8.csv","R8churn.csv","1.0","2.0.0.7");
//		a.computeChurn("R9.csv","R9churn.csv","1.0","2.0.0.10");
//		a.computeChurn("R10.csv","R10churn.csv","1.0","2.0.0.13");
//		a.computeChurn("R11.csv","R11churn.csv","1.0","2.0.0.16");
*/

public class ChurnCVS {
	
	private ArrayList<String> files = new ArrayList<>();

	public static void main(String[] args) throws IOException {
		ChurnCVS a = new ChurnCVS();
		a.computeChurn("R1Churn.csv","R1churnout.csv","1.0","1.0.2");
		
	}
	
	public void computeChurn(String R, String output, String v0, String v1) throws IOException{
		//pegar todos os path
		BufferedReader br_file = new BufferedReader(new FileReader("data/"+R));
		String line = br_file.readLine();
		while (line != null) {
			String file = line.split(",")[0];
			
			files.add(file);
			line = br_file.readLine();
		}
		br_file.close();
		//fim
		
		FileWriter arq_write = new FileWriter("data/"+output);
		BufferedWriter bw = new BufferedWriter(arq_write);
		
		//pegar o log dos path
		for (String path : files) {
			String log="";
			try {
				log = readFile("data/log/"+path, StandardCharsets.UTF_8);
				System.out.println("pegou no arquivo");
			} catch (IOException e) {
				System.out.println("Baixando log de: "+path);
				log = executarComando("cvs log "+path);
				criarArquivo(path, log);
			}
			if(log.equals("")) System.out.println("Não foi possível baixar o log!! Verifique sua conexão com Internet ou Proxy");
			//logs.put(path, log);
			int numChanges = contValue("revision [\\d.]+", log,v0,v1);
			int changeds[] = findValue("(revision [\\d.]+)|(lines: [+\\d]+ [-\\d]+)", log,v0,v1);
			int linesChanged = changeds[0];
			int linesNew = changeds[1];
			
			bw.write(path+","+numChanges+","+linesChanged+","+linesNew+"\n");
		}
		bw.close();
		files.clear();
	}
	
	private String readFile(String nameFile, Charset encoding) throws IOException{
		byte[] enconded = Files.readAllBytes(Paths.get(nameFile));
		return new String(enconded, encoding);
	}
	
	public String executarComando(String comando){

	    Process process = null;
		try {
			process = Runtime.getRuntime().exec(comando);
		} catch (IOException e) {
			e.printStackTrace();
		}  
 
	    InputStream inputStream = process.getInputStream();  

	    String saida = "";  
	  
	    {
	    int n;  
  
	    try {
			while ((n = inputStream.read()) != -1) {  
			    saida += (char)n;  
			}
		} catch (IOException e) {
			e.printStackTrace();
		}  
	    }//aqui a variável n não existe mais.  
	  
	    return saida+"\n";
	}
	
	private void criarArquivo(String path, String log) throws IOException{
		String[] diretorio = path.split("/");
		String endereco = new String(path);
		endereco = endereco.replace(diretorio[diretorio.length-1],"");
		File arquivo = new File("data/log/"+endereco);
		if (!arquivo.exists()) {
			arquivo.mkdirs();
		}
		FileWriter arq_write = new FileWriter("data/log/"+path);
		BufferedWriter bw = new BufferedWriter(arq_write);
		bw.write(log);
		bw.close();
	}

	private int[] findValue(String expressao, String base, String version0, String version1){
		Pattern pattern = Pattern.compile(expressao);
		Matcher matcher = pattern.matcher(base);
		int valor[] = {0,0};
		String revision=new String("");
		String lines=new String("");
		while (matcher.find()) {
			String result = matcher.group();
			if(result.contains("revision"))revision=result;
			else if(result.contains("lines")){
				lines=result;
				String result2 = revision.split(" ")[1];
				if(menorqueVersao(result2, version0)&&maiorqueVersao(result2, version1)){
					String pedaco = lines.split("s: +")[1];
					String mais = pedaco.split(" -")[0];
					String menos = pedaco.split(" -")[1];
					valor[0]+=Integer.parseInt(mais)+Integer.parseInt(menos);
					valor[1]+=Integer.parseInt(mais);
				}
			}
		}
		return valor;
	}
	
	private int contValue(String expressao, String base, String version0, String version1){
		Pattern pattern = Pattern.compile(expressao);
		Matcher matcher = pattern.matcher(base);
		int valor=0;
		while (matcher.find()) {
			String result = matcher.group().split(" ")[1];
			if(menorqueVersao(result, version0)&&maiorqueVersao(result, version1)){
				valor++;
			}
		}
		return valor;
	}
	
	private boolean menorqueVersao(String atual, String paracomparar){
		atual=atual.replace(".", "/");
		paracomparar=paracomparar.replace(".", "/");
		String revision[] = atual.split("/");
		String exigencia[] = paracomparar.split("/");
		int qtde = revision.length;
		if (revision.length>exigencia.length) qtde=exigencia.length;
 		for (int i = 0; i < qtde; i++) {
			if(Integer.parseInt(revision[i])>Integer.parseInt(exigencia[i])) return true;
			else if(Integer.parseInt(revision[i])<Integer.parseInt(exigencia[i])) return false;
		}
 		return true;
	}
	
	private boolean maiorqueVersao(String atual, String paracomparar){
		if(atual.equals(paracomparar)) return true;
		atual=atual.replace(".", "/");
		paracomparar=paracomparar.replace(".", "/");
		String revision[] = atual.split("/");
		String exigencia[] = paracomparar.split("/");
		int qtde = revision.length;
		if (revision.length>exigencia.length) qtde=exigencia.length;
 		for (int i = 0; i < qtde; i++) {
			if(Integer.parseInt(revision[i])<Integer.parseInt(exigencia[i])) return true;
			else if(Integer.parseInt(revision[i])>Integer.parseInt(exigencia[i])) return false;
		}
 		return true;
	}
}