package security.br.ufal.ic.webcolector;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;

import security.br.ufal.ic.xen.FunctionsAndFilePatcherXen;
import security.br.ufal.ic.xen.ProjectXenDAOCOntroller;

public class ExtractingFunctionXen {

	public static ArrayList<Set> getcodeVulnerabilitiesReport() {
		Pattern pattern2 = Pattern.compile("(xsa.*?\\.patch)");

		Set<String> patchs = null;
		ArrayList<Set> temp = new ArrayList<Set>();
		try {
			for (int i = 26; i <= 142; i++) {
				System.out.println(i);
				if (i == 115) {
					i++;
				}
				Document doc = Jsoup.connect("http://xenbits.xen.org/xsa/advisory-" + i + ".html").timeout(100000)
						.ignoreHttpErrors(true).get();
				Elements newsHeadlines = doc.getElementsByAttributeValueEnding("href", ".patch");

				Matcher matcher2 = pattern2.matcher(newsHeadlines.text());

				patchs = new HashSet<String>();
				while (matcher2.find()) {
					patchs.add(matcher2.group(1) + " advisory-" + i);

				}

				temp.add(patchs);
			}

		} catch (Exception e) {
			e.getMessage();
		}
		return temp;
	}

	public static void main(String[] args) throws IOException {

		ProjectXenDAOCOntroller dao = new ProjectXenDAOCOntroller();

		ArrayList<Set> lista = getcodeVulnerabilitiesReport();
		Pattern pattern = Pattern.compile("a\\/(.*?\\S*)");
		Pattern pattern2 = Pattern.compile("(?<=\\s+@@).*?\\s*@@(.*?\\()");

		for (Set<String> s : lista) {
			for (String e : s) {
				Document doc = Jsoup.connect("http://xenbits.xen.org/xsa/" + e.split(" ")[0]).timeout(150000)
						.ignoreHttpErrors(true).get();
				if (doc.text().contains("index ")) {

					String[] docTextList = doc.getElementsByTag("body").html().split("diff ");
					for (String s2 : docTextList) {
						Matcher matcher = pattern.matcher(s2);
						Matcher matcher2 = pattern2.matcher(s2);
						while (matcher.find()) {
							System.out.println(matcher.group(1));
							while (matcher2.find()) {
								FunctionsAndFilePatcherXen fun = new FunctionsAndFilePatcherXen();
								fun.setCommitBefore("");
								fun.setFile(matcher.group(1));
								fun.setPatch(e.split(" ")[0]);
								fun.setFunction(matcher2.group(1));
								dao.addInstaceFUnctionFile(fun);
							}
						}
					}
				}
			}

			// Document doc =
			// Jsoup.connect("http://xenbits.xen.org/xsa/xsa39-pvops-0001-xen-netback-shutdown-the-ring-if-it-contains-garbage.patch").get();
			// String text = doc.getElementsByTag("body").text();
			// Pattern pattern1 = Pattern.compile("(diff
			// --git\\s*\\w\\/)(.*?)(?<=.*)index(.+?\\s)");
			// Matcher matcher1 = pattern1.matcher(text);
			// while(matcher1.find()){
			// System.out.println(matcher1.group(2));
			// System.out.println(matcher1.group(3));
			// }

			// Coletando Funcoes, regex correto
			// Document doc =
			// Jsoup.connect("http://xenbits.xen.org/xsa/xsa39-pvops-0001-xen-netback-shutdown-the-ring-if-it-contains-garbage.patch").get();
			// String text = doc.getElementsByTag("body").text();
			// Pattern pattern1 = Pattern.compile("(?<=\\+\\+\\+\\
			// b\\/)(.*?\\S*)(.*?)(?=diff --git)");
			// Matcher matcher1 = pattern1.matcher(text);
			// Pattern pattern2 =
			// Pattern.compile("(?<=\\s+@@).*?\\s*@@(.*?\\()");
			//// while(matcher1.find()) {
			//// System.out.println(matcher1.group(1));
			// Matcher matcher2= pattern2.matcher(text.split("--- a")[3]);
			// while(matcher2.find()){
			// System.out.println(matcher2.group(1));}
			//
			// //

			// }
			//
		}

	}
}
