package security.br.ufal.ic.temp;

import java.io.IOException;

import security.br.ufal.ic.kernel.KernelClassify;
import security.br.ufal.ic.kernel.ProjectDataControllerKernel;

public class CreateArff {
	// public static void main(String[] args) throws IOException {
	// ProjectDataController dao= new ProjectDataController();
	// FileWriter arq = new
	// FileWriter("/Users/marcuspianco/Documents/workspace/PredictVulnerabilities-ChangeHistory/Arff
	// Files/kernel.arff");
	// PrintWriter gravarArq = new PrintWriter(arq);
	//
	// for (KernelClassify kernelC: dao.getListKenelClassify()) {
	// System.out.println(kernelC.getId());
	//
	// gravarArq.printf("%d,%d,%d,%d,%d,%d,%d,%d,%d",(kernelC.getNConditionalExtraneousChanges()),kernelC.getNConditionalMissingChanges(),kernelC.getNFunctionCallExtraneousChanges(),kernelC.getNFunctionCallMissingChanges(),kernelC.getNMethodExtraneousChanges(),kernelC.getNMethodMissingChanges(),kernelC.getNVariableExtraneousChanges(),kernelC.getNVariableMissingChanges(),kernelC.getVulnerability()
	// );
	// gravarArq.printf("%n");
	//
	// }
	// arq.close();
	// }
	public static void main(String[] args) throws IOException {
		ProjectDataControllerKernel dao = new ProjectDataControllerKernel();

		for (KernelClassify kernelC : dao.getListKenelClassify()) {
			String[] list = kernelC.getFile().split("/");
			
//			System.out.println(list[0]+"/"+list[1]);
			if (kernelC.getModule().contains("drivers/")) {
				kernelC.setModule("drivers");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("mm/")) {
				kernelC.setModule("mm");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("ipc/")) {
				kernelC.setModule("ipc");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("virt/")) {
				kernelC.setModule("virt");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("sound/")) {
				kernelC.setModule("sound");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("include/")) {
				kernelC.setModule("include");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("crypto/")) {
				kernelC.setModule("crypto");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("block/")) {
				kernelC.setModule("block");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("security/")) {
				kernelC.setModule("security");
				dao.updateKernelClassify(kernelC);
			}
			else if (kernelC.getModule().contains("lib/")) {
				kernelC.setModule("lib");
				dao.updateKernelClassify(kernelC);
			}
			
//			

		
	}

	// //Conecta ao banco e a tabela referida
	// ProjectXenDAOCOntroller dao= new ProjectXenDAOCOntroller();
	// //caminho do arff
	// FileWriter arq = new
	// FileWriter("/Users/marcuspianco/Documents/workspace/PredictVulnerabilities-ChangeHistory/Arff
	// Files/xenNovember.arff");
	// PrintWriter gravarArq = new PrintWriter(arq);
	// //insere dados no arff
	// for (XenClassify xenobj: dao.getListXenClassify()) {
	// //%d Ã© cada coluna da tabela que ficara como unidade da tuplas do arff.
	// gravarArq.printf("%d,%d,%d,%d,%d,%d,%d,%d,%s",(xenobj.getNConditionalExtraneousChanges()),xenobj.getNConditionalMissingChanges(),xenobj.getNFunctionCallExtraneousChanges(),xenobj.getNFunctionCallMissingChanges(),xenobj.getNMethodExtraneousChanges(),xenobj.getNMethodMissingChanges(),xenobj.getNVariableExtraneousChanges(),xenobj.getNVariableMissingChanges(),xenobj.getPatch());
	// gravarArq.printf("%n");
	//
	// }
	// arq.close();
	// }
}}
